RANDOM NODE DEPLOYMENT

clc; clear; close all;
N = 10;            
area = 100;        
R = 30;           
nodes = rand(N,2) * area;
figure;
scatter(nodes(:,1), nodes(:,2), 100, 'filled');
text(nodes(:,1)+1, nodes(:,2)+1, string(1:N)); 
title('WSN Node Deployment with Connectivity');
xlabel('X (meters)');
ylabel('Y (meters)');
axis([0 area 0 area]);


------------------------------------------------------------------------------


CONNECTIVITY AND RANGE

clc; clear; close all;
N = 10;            
area = 100;        
R = 30;           
nodes = rand(N,2) * area;
figure;
scatter(nodes(:,1), nodes(:,2), 100, 'filled');
text(nodes(:,1)+1, nodes(:,2)+1, string(1:N)); 
title('WSN Node Deployment with Connectivity');
xlabel('X (meters)');
ylabel('Y (meters)');
axis([0 area 0 area]);
grid on;
hold on;
connectivity = zeros(N,N); 
for i = 1:N
    for j = i+1:N
        dist = norm(nodes(i,:) - nodes(j,:)); 
        if dist <= R
            connectivity(i,j) = 1;
            connectivity(j,i) = 1;
            plot([nodes(i,1), nodes(j,1)], [nodes(i,2), nodes(j,2)], 'g--');
        end
    end
end
disp('Connectivity Matrix:');
disp(connectivity);


------------------------------------------------------------------------------------------------


ENERGY CONSUMPTION

clc;
clear;
numNodes = 100;
areaSize = 100; 
sink = [50, 50];
E_elec = 50e-9;   
E_amp = 100e-12;   
packetSize = 4000;  
initialEnergy = 0.5; 
nodes = rand(numNodes, 2) * areaSize;
energy = initialEnergy * ones(1, numNodes);
for i = 1:numNodes
    d = sqrt((nodes(i,1) - sink(1))^2 + (nodes(i,2) - sink(2))^2);
    ETX = E_elec * packetSize + E_amp * packetSize * d^2;
    energy(i) = energy(i) - ETX;
end
figure;
scatter(nodes(:,1), nodes(:,2), 50, energy, 'filled');
colorbar;
hold on;
plot(sink(1), sink(2), 'kp', 'MarkerSize', 10, 'MarkerFaceColor', 'k');
title('Node Energy after One Transmission Round');
xlabel('X (m)');
ylabel('Y (m)');
grid on;

-----------------------------------------------------------------------------------------------


LEACH

clear all;
clc;

n = 100;
area = 100;
sink = struct('x', 50, 'y', 50);
p = 0.05;
Eo = 0.5;
rmax = 1000;

E_tx_CH = 0.001;
E_tx_nonCH = 0.0005;

for i = 1:n
    S(i).x = rand(1,1)*area;
    S(i).y = rand(1,1)*area;
    S(i).E = Eo;
    S(i).CH = 0;
    S(i).CH_id = 0;
end

alive_nodes = zeros(1, rmax);

for r = 1:rmax
    CHs(r).nodes = [];

    for i = 1:n
        S(i).CH = 0;
        S(i).CH_id = 0;
    end

    for i = 1:n
        if S(i).E > 0 && rand <= p
            S(i).CH = 1;
            CHs(r).nodes(end+1) = i;
        end
    end

    if isempty(CHs(r).nodes)
        [~, idx_max] = max([S.E]);
        if S(idx_max).E > 0
            S(idx_max).CH = 1;
            CHs(r).nodes = idx_max;
        end
    end

    for i = 1:n
        if S(i).E > 0 && S(i).CH == 0
            min_dist = inf;
            closest_CH = 0;
            for j = CHs(r).nodes
                d = sqrt((S(i).x - S(j).x)^2 + (S(i).y - S(j).y)^2);
                if d < min_dist
                    min_dist = d;
                    closest_CH = j;
                end
            end
            S(i).CH_id = closest_CH;
        end
    end

    for i = 1:n
        if S(i).E > 0
            if S(i).CH == 1
                d = sqrt((S(i).x - sink.x)^2 + (S(i).y - sink.y)^2);
                energyConsumed = E_tx_CH * d^2;
                S(i).E = S(i).E - energyConsumed;
                if S(i).E < 0
                    S(i).E = 0;
                end
            else
                j = S(i).CH_id;
                if j > 0 && S(j).E > 0
                    d = sqrt((S(i).x - S(j).x)^2 + (S(i).y - S(j).y)^2);
                    energyConsumed = E_tx_nonCH * d^2;
                    S(i).E = S(i).E - energyConsumed;
                    if S(i).E < 0
                        S(i).E = 0;
                    end
                end
            end
        end
    end

    alive_nodes(r) = sum([S.E] > 0);

    if alive_nodes(r) == 0
        fprintf('All nodes died at round %d\n', r);
        alive_nodes = alive_nodes(1:r);
        break;
    end
end

figure;
plot(1:length(alive_nodes), alive_nodes, 'LineWidth', 2);
xlabel('Rounds');
ylabel('Alive Nodes');
title('Network Lifetime using LEACH');
grid on;

--------------------------------------------------------------------------------------------------------

AODV

clc; clear; close all;
N = 20;              
area = 100;          
tx_range = 20;      
E_init = 0.5;        
rounds = 500;        
for i = 1:N
    Node(i).x = rand * area;      
    Node(i).y = rand * area;      
    Node(i).E = E_init;          
    Node(i).routingTable = [];    
end
Adj = zeros(N,N);
for i = 1:N
    for j = 1:N
        dist = sqrt((Node(i).x - Node(j).x)^2 + (Node(i).y - Node(j).y)^2);
        if dist <= tx_range
            Adj(i,j) = 1;  
        else
            Adj(i,j) = 0;
        end
    end
end
% Pick random source & destination
src = randi(N);
dest = randi(N);
while dest == src
    dest = randi(N);
end
[path, hops] = findAODVRoute(src, dest, Adj);
% --- Plot Network ---
figure;
hold on; grid on; axis([0 area 0 area]);
title(sprintf('AODV Route Discovery (Src=%d â†’ Dest=%d)', src, dest));
xlabel('X'); ylabel('Y');
% Plot connectivity
for i = 1:N
    for j = i+1:N
        if Adj(i,j) == 1
            plot([Node(i).x Node(j).x], [Node(i).y Node(j).y], 'k:', 'LineWidth', 0.5);
        end
    end
end
% Plot all nodes
for i = 1:N
    plot(Node(i).x, Node(i).y, 'bo', 'MarkerFaceColor','b');
    text(Node(i).x+1, Node(i).y+1, num2str(i), 'FontSize', 7);
end
% Highlight source and destination
plot(Node(src).x, Node(src).y, 'gs', 'MarkerSize',10, 'MarkerFaceColor','g'); % source
plot(Node(dest).x, Node(dest).y, 'rs', 'MarkerSize',10, 'MarkerFaceColor','r'); % destination
% Highlight discovered route
if ~isempty(path)
    for k = 1:length(path)-1
        i = path(k); j = path(k+1);
        plot([Node(i).x Node(j).x], [Node(i).y Node(j).y], 'r-', 'LineWidth', 2);
    end
    legend('Links','Nodes','Source','Destination','Route');
else
    legend('Links','Nodes','Source','Destination');
    disp('No route found between source and destination.');
end
hold off;
% --- AODV ROUTE DISCOVERY FUNCTION ---
function [path, hops] = findAODVRoute(src, dest, Adj)
    visited = zeros(1, length(Adj));  
    path = [];                        
    queue = {src};                    
    parent = zeros(1, length(Adj));    
    while ~isempty(queue)
        current = queue{1};
        queue(1) = [];
        visited(current) = 1;
        if current == dest
            break;
        end
        for neighbor = find(Adj(current,:))
            if ~visited(neighbor)
                queue{end+1} = neighbor;
                if parent(neighbor) == 0
                    parent(neighbor) = current;
                end
            end
        end
    end
    if parent(dest) ~= 0
        node = dest;
        while node ~= src
            path = [node, path];
            node = parent(node);
        end
        path = [src, path];
        hops = length(path) - 1;
    else
        path = [];
        hops = Inf;  
    end
end

-------------------------------------------------------------------------------------------------

DATA AGGREGATION

clc; clear; close all;
N = 50;             
area = 100;         
K = 5;               
x = rand(1, N) * area;
y = rand(1, N) * area;
sensor_values = 20 + randn(1, N);  
X = [x' y'];
[cluster_idx, cluster_centers] = kmeans(X, K);
aggregated_data = zeros(1, K);
for k = 1:K
    cluster_nodes = find(cluster_idx == k);
    values = sensor_values(cluster_nodes);
    aggregated_data(k) = mean(values);  
end
figure;
gscatter(x, y, cluster_idx);
hold on;
plot(cluster_centers(:,1), cluster_centers(:,2), 'kx', 'MarkerSize', 15, 'LineWidth', 2);
title('WSN Node Clustering and Aggregation');
xlabel('X (m)');
ylabel('Y (m)');
legend('Cluster 1','Cluster 2','Cluster 3','Cluster 4','Cluster 5','Cluster Heads');
disp("Aggregated Data from Each Cluster:");
disp(aggregated_data);
reduction_ratio = (N - K) / N * 100;
fprintf('\nData Reduction: %.2f%%\n', reduction_ratio);

---------------------------------------------------------------------------------------------------

LOCALIZATION

clc;
clear;
close all;
anchor1 = [0, 0];
anchor2 = [100, 0];
anchor3 = [50, 86.6];

true_pos = [50, 40];

d1 = norm(true_pos - anchor1);
d2 = norm(true_pos - anchor2);
d3 = norm(true_pos - anchor3);

noise_level = 0.5;
d1 = d1 + randn * noise_level;
d2 = d2 + randn * noise_level;
d3 = d3 + randn * noise_level;

A = [2*(anchor2(1) - anchor1(1)), 2*(anchor2(2) - anchor1(2));
2*(anchor3(1) - anchor1(1)), 2*(anchor3(2) - anchor1(2))];

b = [d1^2 - d2^2 + anchor2(1)^2 - anchor1(1)^2 + anchor2(2)^2 - anchor1(2)^2;
d1^2 - d3^2 + anchor3(1)^2 - anchor1(1)^2 + anchor3(2)^2 - anchor1(2)^2];

estimated_pos = (A \ b)';

fprintf('Estimated Position: (%.2f, %.2f)\n', estimated_pos(1), estimated_pos(2));
fprintf('True Position: (%.2f, %.2f)\n', true_pos(1), true_pos(2));
error = norm(estimated_pos - true_pos);
fprintf('Localization Error: %.2f units\n', error);

figure;
hold on; grid on;
plot(anchor1(1), anchor1(2), 'ro', 'MarkerSize', 10);
plot(anchor2(1), anchor2(2), 'go', 'MarkerSize', 10);
plot(anchor3(1), anchor3(2), 'bo', 'MarkerSize', 10);
plot(true_pos(1), true_pos(2), 'k*', 'MarkerSize', 10);
plot(estimated_pos(1), estimated_pos(2), 'ms', 'MarkerSize', 10);
legend;
title('Trilateration-based Node Localization');
xlabel('X Coordinate');
ylabel('Y Coordinate');


-------------------------------------------------------------------------------

FAULT TOLERANCE

clc; clear; close all;
numNodes = 50;
range = 30; 
areaSize = 100;
failRate = 0.2; 
positions = areaSize * rand(numNodes, 2);
sink = [areaSize/2, areaSize/2];
D = squareform(pdist(positions));
adjMatrix = D < range & D > 0;
numFail = round(numNodes * failRate);
failedNodes = randperm(numNodes, numFail);
adjMatrix(failedNodes, :) = 0;
adjMatrix(:, failedNodes) = 0;
figure;
gplot(adjMatrix, positions, '-*');
hold on;
plot(sink(1), sink(2), 'ro', 'MarkerSize', 10, 'LineWidth', 2);
title('WSN with Node Failures');
legend('Connections', 'Sink');
sourceNode = 1;
if ismember(sourceNode, failedNodes)
    disp('Source node has failed!');
else
    G = graph(adjMatrix);
    try
        [path, ~] = shortestpath(G, sourceNode, numNodes); 
        fprintf('Path from node %d to sink: ', sourceNode);
        disp(path);
    catch
        disp('No path to sink due to node failure!');
    end
end

---------------------------------------------------------------------------------------

QOS

N = 50;
area = 100;
x = rand(1,N) * area;
y = rand(1,N) * area;
BS = [50, 50];

figure;
scatter(x, y, 'b', 'filled'); hold on;
plot(BS(1), BS(2), 'r^', 'MarkerSize', 10, 'MarkerFaceColor', 'r');
title('Wireless Sensor Network Topology');
xlabel('X (m)'); ylabel('Y (m)');
legend('Sensor Nodes', 'Base Station');
grid on;

num_packets = 1000;
packet_send_time = sort(rand(1, num_packets) * 100);
delay = rand(1, num_packets) * 0.2 + 0.1;
packet_receive_time = packet_send_time + delay;
packet_lost = rand(1, num_packets) < 0.1;
packet_received = ~packet_lost;

duration = max(packet_receive_time) - min(packet_send_time);
received_packets = sum(packet_received);
throughput = received_packets / duration;
fprintf('Throughput: %.2f packets/sec\n', throughput);

PDR = received_packets / num_packets;
fprintf('Packet Delivery Ratio: %.2f%%\n', PDR * 100);

avg_delay = mean(delay(packet_received));
fprintf('Average End-to-End Delay: %.4f seconds\n', avg_delay);

recv_times = packet_receive_time(packet_received);
jitter = std(diff(recv_times));
fprintf('Jitter: %.4f seconds\n', jitter);

figure;
plot(packet_receive_time(packet_received), 1:received_packets, 'g');
xlabel('Time (s)');
ylabel('Cumulative Received Packets');
title('Packet Arrival Over Time');
grid on;





